# -*- coding: utf-8 -*-
"""
Created on Mon May 13 20:21:44 2019

@author: umorf

This module contains the structure_analysis function, which uses all other 
functions of the package.
"""

from .apply_boundary_conditions import apply_boundary_conditions
from .assembly import assemble
from .back_calculation import get_internal_forces
from .discretization import discretize
from .make_lists import get_dictionaries
from .points_of_interest import calculate_state_poi
from .solve import solve
from .verification import verify_input


def structure_analysis(model, *points_of_interest,
                       discType='Elementwise', discElements=100, discLength=0.1):
    """Calculates the support reactions, the deformations and internal forces of the model.
    
    -----
    
    Objective:
        
    The function discretizes and calculates the support reactions, the
    deformation and the internal forces of the model for each loadgroup.
    
    If points of interest are specified, only the state (displacements and 
    internal forces) of these points is returned. If not, the states of all
    nodes generated by the discretization of the system is returned. As a third
    output the support reactions are always returned.
    -----
    
    Structure:
    
    First the model is verified. For bigger mistakes a Warning (Error) is raised.
    Some smaller issues are fixed by the function itsself. (see verification)
    
    The method of the discretization of the system is controlled by the keyword
    arguments. It subdivides each beam into smaller Elements. (see discretization)
    
    The stiffness matrix and the force matrix (one column for each loadgroup)
    are assembled. The force matrix is assembled using the shape function,
    whereas the stiffness matrix is assembled in sparse format using the 
    hardcoded local stiffness matrices. (see subpackage assembly)
    
    The stiffness matrix and the force matrix are split according to the
    restricted degrees. (see apply_boundary_conditions)
    
    The system is solved using scipy.sparse.linalg.spsolve, which provides very
    fast and for normal sized systems sufficiently accurate displacements as
    solution. Further the support reactions are calculated. (see solve)
    
    From these displacements the internal forces are backcalculated for each 
    element and combined with the internal forces resulting from assembling the 
    loads of the system (see back_calculation)
    
    If no points of interest are specified, the internal forces and displacements
    are returned beamwise for all generated nodes of each beam. They are returned
    in two dictionaries per loadgroup (see make_lists)
    
    If points of interest are specified, the displacement and the internal
    forces are calculated and returned in two lists with dictionaries for each
    loadgroup (see points_of_interest)
    -----
    
    Limitations:
        The accuracy of the solver can become apparent, for example in 
        statically defined systems with initial displacements have non-zero 
        internal forces
        Initial displacements can only be applied to restricted degrees of freedom
        For finite shear stiffness, a low amount of discretization elements 
        leads to inaccurate results.
    -----
    
    Arguments:
        model -- the structural model as a dictionary. Containing the nodes,
                 beams, loads and boundary conditions
        
    Optional arguments:
        points_of_interest -- a list of points, for which the state is to be
                              calculated
        
    Keyword arguments:
        discType     -- describes the method of discretizing the beams. Either 
                        'Elementwise' or 'Lengthwise'
        discElements -- the amount of elements each beam is subdivided into if 
                        discType is 'Elementwise' 
        disclength   -- the length of the beams elements the maximal length of 
                        the elements each beam is subdivided into if discType 
                        is 'Lengthwise'
        
    Return values:
        deformations      -- a list containing a dictionary of the deformations
                             for each loadgroup, either of all created nodes or
                             the points of interest
        internal_forces   -- a list containing a dictionary of the internal
                             forces for each loadgroup, either of all created
                             nodes or the points of interest
        support_reactions -- a list of the restricted nodes and their support 
                             reactions
    """
    # Abbreviations:
    # d    = displacements
    # if   = internal forces
    # mat  = matrix
    # disc = discretization

    nodes = model['Nodes']
    beams = model['Beams']
    loads = model['Loads']
    boundary_conditions = model['Boundary Conditions']

    # Verify the input.
    verify_input(model)

    # Discretize the structure.
    disc_information = discretize(nodes, beams, discType, discElements, discLength)

    # Get the global stiffness and force matrix and the internal forces from assembling.
    stiffness_mat, force_mat, if_mat_assembly = assemble(model, disc_information)

    # Apply the boundary conditions to the stiffness and the force matrix
    modified_matrices = apply_boundary_conditions(boundary_conditions,
                                                  stiffness_mat, force_mat)

    # Solve the system and create the support reactions list.
    d_mat, support_reactions = solve(modified_matrices, loads, boundary_conditions)

    # Get the elementwise displacements and calculate the internal forces.
    id_matrix, if_matrices = get_internal_forces(beams, d_mat, if_mat_assembly,
                                                 disc_information)

    # Create the dictionaries to return, depending on whether points of interest
    # are specified or not.
    if not points_of_interest:

        # Create Lists of dictionaries containing the data of all nodes.
        d_dict, if_dict = get_dictionaries(disc_information, id_matrix, if_matrices)

    else:
        # Create Lists of dictionaries containing the data of the points of interest.
        d_dict, if_dict = calculate_state_poi(loads, points_of_interest,
                                              disc_information, id_matrix,
                                              if_matrices)

    deformations = d_dict
    internal_forces = if_dict

    return deformations, internal_forces, support_reactions
